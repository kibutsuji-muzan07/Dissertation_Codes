# Parsing the csv generated by the data segregator
def parse_csv(file):
    # Load the CSV file into a DataFrame
    data = pd.read_csv(file)

    # Initialize empty DataFrames
    cmd_df = pd.DataFrame()
    terrain_df = pd.DataFrame()
    lidar_df = pd.DataFrame()
    gps_df = pd.DataFrame()
    att_df = pd.DataFrame()
    ned_df = pd.DataFrame()

    # Iterate through the DataFrame rows and filter for "CMD" type messages
    for _, row in data.iterrows():
        # Check if the row is a CMD message based on the 'message_type' column
        try:


          if row['message_type'] == 'CMD':
                  fields_str = row['fields']
                  if isinstance(fields_str, str):
                      fields = ast.literal_eval(fields_str)  # Safely parse the string as a Python dictionary
                  else:
                      fields = row['fields']  # Already in dictionary format if not a string

                  # Append row data to the cmd_df DataFrame
                  cmd_df = pd.concat([cmd_df, pd.DataFrame({
                      'timestamp': [row['timestamp']],
                      'CNum': [fields.get('CNum', None)],      # Use 'get' to avoid KeyErrors if column missing
                      'CId': [fields.get('CId', None)],
                      'lat': [fields.get('Lat', None)],
                      'lng': [fields.get('Lng', None)],
                      'alt': [fields.get('Alt', None)]
                  })], ignore_index=True)


          elif row['message_type'] == 'TERR':
                  fields_str = row['fields']
                  if isinstance(fields_str, str):
                      fields = ast.literal_eval(fields_str)  # Safely parse the string as a Python dictionary
                  else:
                      fields = row['fields']  # Already in dictionary format if not a string

                  # Append row data to the terrain_df DataFrame
                  terrain_df = pd.concat([terrain_df, pd.DataFrame({
                        'timestamp': [row['timestamp']],
                        'lat': [fields.get('Lat', None)],
                        'lng': [fields.get('Lng', None)],
                        'terrain_height': [fields.get('TerrH', None)]
                    })], ignore_index=True)


          elif row['message_type'] == 'RFND':
                  fields_str = row['fields']
                  if isinstance(fields_str, str):
                      fields = ast.literal_eval(fields_str)  # Safely parse the string as a Python dictionary
                  else:
                      fields = row['fields']  # Already in dictionary format if not a string

                  # Append row data to the terrain_df DataFrame
                  lidar_df = pd.concat([lidar_df, pd.DataFrame({
                        'timestamp': [row['timestamp']],
                        'lidar_height': [fields.get('Dist', None)]
                    })], ignore_index=True)


          elif row['message_type'] == 'GPS':
                  fields_str = row['fields']
                  if isinstance(fields_str, str):
                      fields = ast.literal_eval(fields_str)  # Safely parse the string as a Python dictionary
                  else:
                      fields = row['fields']  # Already in dictionary format if not a string

                  # Append row data to the terrain_df DataFrame
                  gps_df = pd.concat([gps_df, pd.DataFrame({
                        'timestamp': [row['timestamp']],
                         'gps_lat': [fields.get('Lat', None)],
                        'gps_lng': [fields.get('Lng', None)],
                        'gps_height': [fields.get('Alt', None)],
                        'speed': [fields.get('Spd', None)]
                    })], ignore_index=True)


          elif row['message_type'] == 'ATT':
                  fields_str = row['fields']
                  if isinstance(fields_str, str):
                      fields = ast.literal_eval(fields_str)  # Safely parse the string as a Python dictionary
                  else:
                      fields = row['fields']  # Already in dictionary format if not a string

                  # Append row data to the terrain_df DataFrame
                  att_df = pd.concat([att_df, pd.DataFrame({
                        'timestamp': [row['timestamp']],
                        'roll': [fields.get('Roll', None)],
                        'pitch': [fields.get('Pitch', None)],
                        'yaw':[fields.get('Yaw', None)]
                    })], ignore_index=True)


          elif row['message_type'] == 'SRTL':
                  fields_str = row['fields']
                  if isinstance(fields_str, str):
                      fields = ast.literal_eval(fields_str)  # Safely parse the string as a Python dictionary
                  else:
                      fields = row['fields']  # Already in dictionary format if not a string

                  # Append row data to the terrain_df DataFrame
                  ned_df = pd.concat([att_df, pd.DataFrame({
                        'timestamp': [row['timestamp']],
                        'N': [fields.get('N', None)],
                        'E': [fields.get('E', None)],
                        'D':[fields.get('D', None)]
                    })], ignore_index=True)
        except ValueError as error:
            print(f"Skipping message due to error: {error}")


    # Interpolating roll, pitch and yaw to gps timestamps
    if not att_df.empty and not lidar_df.empty:
        try:
            roll_interp = interp1d(att_df['timestamp'], att_df['roll'], kind='nearest', fill_value="extrapolate")
            pitch_interp = interp1d(att_df['timestamp'], att_df['pitch'], kind='nearest', fill_value="extrapolate")
            yaw_interp = interp1d(att_df['timestamp'], att_df['yaw'], kind='nearest', fill_value="extrapolate")
            lidar_df['roll'] = roll_interp(lidar_df['timestamp'])
            lidar_df['pitch'] = pitch_interp(lidar_df['timestamp'])
            lidar_df['yaw'] = yaw_interp(lidar_df['timestamp'])
        except ValueError as att_error:
            print(f"Error interpolating attitude data: {att_error}")

    # Interpolating terrain height with lidar_df
    if not terrain_df.empty and not lidar_df.empty:
        try:
            terrain_interp_height = interp1d(terrain_df['timestamp'], terrain_df['terrain_height'], kind='nearest', fill_value="extrapolate")
            terrain_interp_lat = interp1d(terrain_df['timestamp'], terrain_df['lat'], kind='nearest', fill_value="extrapolate")
            terrain_interp_lng = interp1d(terrain_df['timestamp'], terrain_df['lng'], kind='nearest', fill_value="extrapolate")
            lidar_df['terrain_height'] = terrain_interp_height(lidar_df['timestamp'])
            lidar_df['terrain_lat'] = terrain_interp_lat(lidar_df['timestamp'])
            lidar_df['terrain_lng'] = terrain_interp_lng(lidar_df['timestamp'])

        except ValueError as terrain_error:
            print(f"Error interpolating terrain data: {terrain_error}")

    # Interpolating lidar height to gps timestamps
    if not lidar_df.empty and not gps_df.empty:
        try:
            gps_interp_height = interp1d(gps_df['timestamp'], gps_df['gps_height'], kind = 'nearest', fill_value="extrapolate")
            gps_interp_lat = interp1d(gps_df['timestamp'], gps_df['gps_lat'], kind = 'nearest', fill_value="extrapolate")
            gps_interp_lng = interp1d(gps_df['timestamp'], gps_df['gps_lng'], kind = 'nearest', fill_value="extrapolate")
            gps_interp_speed = interp1d(gps_df['timestamp'], gps_df['speed'], kind = 'nearest', fill_value="extrapolate")
            lidar_df['gps_height'] = gps_interp_height(lidar_df['timestamp'])
            lidar_df['gps_lat'] = gps_interp_lat(lidar_df['timestamp'])
            lidar_df['gps_lng'] = gps_interp_lng(lidar_df['timestamp'])
            lidar_df['speed'] = gps_interp_speed(lidar_df['timestamp'])
        except ValueError as gps_error:
            print(f"Error interpolating GPS data: {gps_error}")


    if not ned_df.empty and not lidar_df.empty:
        try:
            ned_interp_n = interp1d(ned_df['timestamp'], ned_df['N'], kind = 'nearest', fill_value="extrapolate")
            lidar_df['N'] = ned_interp_n(lidar_df['timestamp'])
            ned_interp_e = interp1d(ned_df['timestamp'], ned_df['E'], kind = 'nearest', fill_value="extrapolate")
            lidar_df['E'] = ned_interp_e(lidar_df['timestamp'])
            ned_interp_d = interp1d(ned_df['timestamp'], ned_df['D'], kind = 'nearest', fill_value="extrapolate")
            lidar_df['D'] = ned_interp_d(lidar_df['timestamp'])
        except ValueError as ned_error:
            print(f"Error interpolating LIDAR data: {ned_error}")


    if 'roll' in lidar_df and 'pitch' in lidar_df and 'yaw' in lidar_df:
        lidar_df['deviated_angle'] = lidar_df.apply(
        lambda row: calculate_laser_angle(row['roll'], row['pitch']), axis=1)

        lidar_df['corrected_lidar_height'] = lidar_df['lidar_height'] * np.cos(np.radians(lidar_df['deviated_angle']))

    # Apply offset to align lidar with terrain heights
    lidar_df['adjusted_drone_height'] = lidar_df['corrected_lidar_height'] + lidar_df['terrain_height']

    lidar_df['terrain_trace_from_lidar'] = lidar_df['gps_height'] - lidar_df['corrected_lidar_height']

    # Return the processed DataFrame
    return lidar_df, cmd_df